---
title: "Raster_Stack_Rgee_Creation"
author: "Miles Van Denburg"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown


```{r}
library(greenbrown)
library(sf)
library(sp)
library(tidyverse)
# devtools::install_github("rstudio/reticulate")

#Install if you don't have already
# remotes::install_github("r-spatial/rgee")
library(rgee)


ee_install()
ee_Initialize(email = 'miles.vandenburg@gmail.com')

library(reticulate)

# ee_check()

# install.packages(c('processx','ps'))
packageVersion('rgee')
# rgee::ee_check()
# reticulate::py_config()

# ee_clean_pyenv()
# ee_clean_credentials()
# ee_Initialize()


ee = import("ee")          # Import the Earth Engine library
ee$Initialize() 

np = import("numpy")      # Import Numpy 

py_install("pandas")       #Install Pandas if you don't have it already installed

pd = import("pandas")      # Import Pandas

sys = import("sys")

sys.maxsize()



```


Bring on the RGEE Objects and Vectors
```{r}
# coords_2 <- matrix(c(-71.8215424722187, 42.267434489848135,
#     -71.8215424722187, 42.26733574244465,
#     -71.8213366126768, 42.26733574244465,
#     -71.8213366126768, 42.267434489848135,
#     -71.8215424722187, 42.267434489848135),
#     ncol = 2, byrow = TRUE)
# 
# 
# P1 <- Polygon(coords_2)
# Ps1 <-  SpatialPolygons(list(Polygons(list(P1), ID = "a")), proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))
# plot(Ps1, axes = TRUE)
# 
# ps2 <- st_as_sf(Ps1)
# 
# 
# polygon = ee$Geometry$Polygon(
#   list(
#     c(-71.8215424722187, 42.267434489848135),
#     c(-71.8215424722187, 42.26733574244465),
#     c(-71.8213366126768, 42.26733574244465),
#     c(-71.8213366126768, 42.267434489848135),
#     c(-71.8215424722187, 42.267434489848135)
#   )
# )


# Most important for us
eco_mask <- st_read('Ecoregion.shp',quiet = TRUE) %>% st_transform(4326) 

eco_mask_ee <- sf_as_ee(eco_mask)

#Smaller ecoregion

eco_mask2 <- st_read('Ecoregion_Small.shp',quiet = TRUE) %>% st_transform(4326) 
# 
eco_mask_ee2 <- sf_as_ee(eco_mask2)

```


Bring in the imagery from RGEE

```{r}
s3 <- ee$ImageCollection('LANDSAT/LT05/C01/T1_32DAY_EVI')

s3 <-  s3$filterDate(ee$Date('2000-01-01'),ee$Date('2008-01-01'))$filterBounds(eco_mask_ee)




#Show the amount of images in the collection
nbrImages_s3 = s3$size()$getInfo()
nbrImages_s3


#Mapping the clip function over the collection
s3 = s3$map(function(image){image$clip(eco_mask_ee)})

#Selecting the EVI band which holds the information
s3 = s3$select("EVI")

#Get information about the collection 
sinfo <- s3$getInfo()


#get more information on what's stored in the bands
# s3$bandNames()$size()$getInfo()

```



Same code but with smaller ecoregion


```{r}
s4 <- ee$ImageCollection('LANDSAT/LT05/C01/T1_32DAY_EVI')

s4 <-  s4$filterDate(ee$Date('2000-01-01'),ee$Date('2008-01-01'))$filterBounds(eco_mask_ee2)




#Show the amount of images in the collection
nbrImages_s4 = s4$size()$getInfo()
nbrImages_s4


#Mapping the clip function over the collection
s4 = s4$map(function(image){image$clip(eco_mask_ee2)})

#Selecting the EVI band which holds the information
s4 = s4$select("EVI")

#Get information about the collection 
s4info <- s4$getInfo()


#get more information on what's stored in the bands
# s3$bandNames()$size()$getInfo()

```



Get setup for the loop.  In case the loop crashes or doesn't work, you must rerun the above chunk first before running this chunk again. 
```{r}
nimages <- s3$size()$getInfo()
ic_date <- ee_get_date_ic(s3)


s2_img_list <- list()
latlng <- list()
lats <- list()
lngs <- list()
evi_values <- list()
s2_names <- list()

evi_values2 <- list()
evi_values3 <- list()


# s2_img_list[[15]]$getInfo()

for(i in seq_len(nimages)) {
  py_index <- i - 1
  s2_img <- ee$Image(s3$toList(1, py_index)$get(0))
  s2_name <- s2_img$get('system:index')$getInfo()
  s2_names[[i]] <- s2_name
  s2_img <- s2_img$select("EVI")$rename(s2_name)
  s2_img_list[[i]] <- ee$Image$pixelLonLat()$addBands(s2_img)
  s2_img_list[[i]] <-  s2_img_list[[i]]$reduceRegion(reducer = ee$Reducer$toList(),
                                                        geometry  = eco_mask_ee,
                                                        maxPixels = 1e6,
                                                        scale = 30,
                                                        bestEffort = TRUE)
}


lats <-  np$array((ee$Array(s2_img_list[[1]]$get("latitude"))$getInfo()))
lngs  <- np$array((ee$Array(s2_img_list[[1]]$get("longitude"))$getInfo()))

# 
# 
# for (f in evi_tester)){
# np$array((evi_tester[[f]]))
# }
# 
# np$array2string
# 
# 
# 
# 
# 
# for(x in seq_len(nimages)) {
#   evi_values2[[x]] <-  np$array((ee$Array(s2_img_list[[x]]$get(s2_names[[x]]))$getInfo()))
#         if(i <= 20) {
#                 ## Skip the first 20 iterations
#                 next                 
#         }
#         ## Do something here
# }
# 
# index = 1
# evi_values2 <-list()
# evi_values3 <- list()
# while(nimages >= index) {
#          if(index <= 26 ) {  ## random walk
#           evi_values2[[index]] <-  np$array((ee$List(s2_img_list[[index]]$get(s2_names[[index]]))$getInfo()))
# 
#                  index <- index + 1
#          }else {
#           evi_values3[[index]] <-  np$array((ee$Array(s2_img_list[[index]]$get(s2_names[[index]]))$getInfo()))
# 
#                index <- index + 1
#          } 
#  }
# > print(z)
# 
#       # if (27 > index){
#       # evi_values[[index]] <-  np$array((ee$Array(s2_img_list[[index]]$get(s2_names[[index]]))$getInfo()))
#       # }else{
#       # evi_values2[[index]] <-  np$array((ee$Array(s2_img_list[[index]]$get(s2_names[[index]]))$getInfo()))
#       # }else {
#       #    print('What a great day!')
#       # }
# 
#   # lats[[index]] <-  np$array((ee$Array(s2_img_list[[index]]$get("latitude"))$getInfo()))
#   # lngs[[index]]  <- np$array((ee$Array(s2_img_list[[index]]$get("longitude"))$getInfo()))
#   # evi_values[[index]] <-  np$array((ee$Array(s2_img_list[[index]]$get(s2_name))$getInfo()))
```







Get setup for the loop.  In case the loop crashes or doesn't work, you must rerun the above chunk first before running this chunk again. 
```{r}
nimages2 <- s4$size()$getInfo()
ic_date2 <- ee_get_date_ic(s4)


s4_img_list <- list()
latlng2 <- list()
lats2 <- list()
lngs2 <- list()
evi_values4 <- list()
s4_names <- list()

evi_values5 <- list()
evi_values6 <- list()


# s2_img_list[[15]]$getInfo()

for(i in seq_len(nimages2)) {
  py_index <- i - 1
  s4_img <- ee$Image(s4$toList(1, py_index)$get(0))
  s4_name <- s4_img$get('system:index')$getInfo()
  s4_names[[i]] <- s4_name
  s4_img <- s4_img$select("EVI")$rename(s4_name)
  s4_img_list[[i]] <- ee$Image$pixelLonLat()$addBands(s4_img)
  s4_img_list[[i]] <-  s4_img_list[[i]]$reduceRegion(reducer = ee$Reducer$toList(),
                                                        geometry  = eco_mask_ee2,
                                                        maxPixels = 1e6,
                                                        scale = 30,
                                                        bestEffort = TRUE)
}


lats2 <-  np$array((ee$Array(s4_img_list[[1]]$get("latitude"))$getInfo()))
lngs2 <- np$array((ee$Array(s4_img_list[[1]]$get("longitude"))$getInfo()))

# 
# 
# for (f in evi_tester)){
# np$array((evi_tester[[f]]))
# }
# 
# np$array2string
# 
# 
# 
# 
# 
# for(x in seq_len(nimages)) {
#   evi_values2[[x]] <-  np$array((ee$Array(s2_img_list[[x]]$get(s2_names[[x]]))$getInfo()))
#         if(i <= 20) {
#                 ## Skip the first 20 iterations
#                 next                 
#         }
#         ## Do something here
# }
# 
# index = 1
# evi_values2 <-list()
# evi_values3 <- list()
# while(nimages >= index) {
#          if(index <= 26 ) {  ## random walk
#           evi_values2[[index]] <-  np$array((ee$List(s2_img_list[[index]]$get(s2_names[[index]]))$getInfo()))
# 
#                  index <- index + 1
#          }else {
#           evi_values3[[index]] <-  np$array((ee$Array(s2_img_list[[index]]$get(s2_names[[index]]))$getInfo()))
# 
#                index <- index + 1
#          } 
#  }
# > print(z)
# 
#       if (27 > index){
#       # evi_values[[index]] <-  np$array((ee$Array(s2_img_list[[index]]$get(s2_names[[index]]))$getInfo()))
#       # }else{
#       # evi_values2[[index]] <-  np$array((ee$Array(s2_img_list[[index]]$get(s2_names[[index]]))$getInfo()))
#       # }else {
#       #    print('What a great day!')
#       # }
# 
#   # lats[[index]] <-  np$array((ee$Array(s2_img_list[[index]]$get("latitude"))$getInfo()))
#   # lngs[[index]]  <- np$array((ee$Array(s2_img_list[[index]]$get("longitude"))$getInfo()))
#   # evi_values[[index]] <-  np$array((ee$Array(s2_img_list[[index]]$get(s2_name))$getInfo()))
```




Obtain the EVI values and clean the results of the google earth engine list
```{r}

#For loop to extract all the iamges from the s2_img_list list containing them and converting them to ee.List elements storing them in the evi_values2 list. 
for(index in seq_len(nimages)) {
      evi_values2[[index]] <-  ee$List(s2_img_list[[index]]$get(s2_names[[index]]))$getInfo()
      
}

evi_values<- evi_values2

funny <- function(x){
  np$array((x))
}


#Convert list elements of evi_values into num py arrays
evi_values <- lapply(evi_values,function(x){
  np$array((x))
})


#Lapply method -- takes same amount of time 1:37 for 36 images. 
# evi_values4 <- list()
# evi_values5 <- lapply(seq_len(nimages),function(x){
#   evi_values4[[x]] <-  ee$List(s2_img_list[[x]]$get(s2_names[[x]]))$getInfo()
# })
# 
# 


#Create copy of evi values and rename the columns of the elements
evis <- evi_values
names(evis) <- ic_date$id
```


Same code as aabove but for smaller region

```{r}

#For loop to extract all the iamges from the s2_img_list list containing them and converting them to ee.List elements storing them in the evi_values2 list. 

for(index in seq_len(nimages2)) {
      evi_values4[[index]] <-  ee$List(s4_img_list[[index]]$get(s4_names[[index]]))$getInfo()
      
}

# evi_values5 <- evi_values4

funny <- function(x){
  np$array((x))
}


#Convert list elements of evi_values into num py arrays
evi_values5 <- lapply(evi_values4,function(x){
  np$array((x))
})





#Lapply method -- takes same amount of time 1:37 for 36 images. 
# evi_values4 <- list()
# evi_values5 <- lapply(seq_len(nimages),function(x){
#   evi_values4[[x]] <-  ee$List(s2_img_list[[x]]$get(s2_names[[x]]))$getInfo()
# })
# 
# 


#Create copy of evi values and rename the columns of the elements
eviss4 <- evi_values5
names(eviss4) <- ic_date2$id
```



Convert list to matrix and create dataframe out of the lats, longs, and evi values


```{r}

# names(evi_tester) <- ic_date$id

evis_df <- data.frame(x = lngs,y = lats,lapply(evis, "length<-", max(lengths(evis))))

library(raster)
XYZ_2 <- rasterFromXYZ(evis_df, crs = '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs')

```

Same code as above but smaller eco region


```{r}

library(raster)
library(qdapRegex)
library(lubridate)

# names(evi_tester) <- ic_date$id

evis_df_s4 <- data.frame(x = lngs2,y = lats2,lapply(eviss4, "length<-", max(lengths(eviss4))))

#Averaging function to fill in missing values
# evis_df_s4[29]
#   pos <- grep(pattern = "NA", x = evis_df_s4)
#   evis_df_s4[pos] <- (evis_df_s4[96+1]-evis_df_s4[96-1])/2
# 
#   
# i <- 1
# while(length(pos) > 0)
# 
# i <- length(pos)
# 
#   
# if(length(pos) > 0){
#   evis_df_s4[pos[i]] <- (evis_df_s4[pos[i]+1]-evis_df_s4[pos[i]-1])/2
#   i <- i+1
#   pos <- grep(pattern = "NA", x = evis_df_s4)
# 
#   
# } else if(pos == ncol(evis_df_s4)){
#     evis_df_s4[pos[i]] <- evis_df_s4[ncol(evis_df_s4)]
# } else
#   print(evis_df_s4)
pos <- grep(pattern = "NA", x = evis_df_s4)
while(length(pos)>0){
  for(t in pos){
    if(t < ncol(evis_df_s4)){
    evis_df_s4[t] <- (evis_df_s4[t+1]-evis_df_s4[t-1])/2
    }else
    evis_df_s4[t] <- evis_df_s4[ncol(evis_df_s4)-1]
  }
  pos <- grep(pattern = "NA", x = evis_df_s4)

}

#Test out final column
evis_df_s4[96]


# grep(pattern = "NA", x = evis_df_s4)
# is.na(evis_df_s4)
  
  
# grep(pattern = "-", x = ic_date2[2])
idcy <-  ic_date2$time_start
dates <- ymd(idcy)

# correct_dates <- seq(dates[1], dates[length(dates)], by = 'year')

# correct_dates <- seq(ymd('2000-01-01'),ymd('2003-12-01'),by='months')

#add reformatted dates

names(evis_df_s4)[3:length(evis_df_s4)] <- as.character(dates)
evis_df_s4_2 <- evis_df_s4 %>%
   mutate_all(as.numeric)


evis_df_s4_2 <- evis_df_s4 %>%
   mutate_all(as.numeric)

# seq(ymd('2000-01-01'),ymd('2003-12-01'),by='months')
```


### Step to create the raster

```{r}

XYZ_S4 <- rasterFromXYZ(evis_df_s4_2, crs = '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs')
xyzstack <-  stack(XYZ_S4)

```

**Greenbrown**
```{r}
#phenology for  1 pixel
#select 1 pixel 
evis_df_s4_2
# pixelly <- list()
# evis_df_s4_2 <- evis_df_s4 %>% select (-c(x, y))
# for (i in nrow(evis_df_s4_2)*length(evis_df_s4_2)){
# pixelly[[i]] <- evis_df_s4_2 %>% arrange() %>% slice(i) %>% t() 
# }
# 
# 
# eviiiii <-  lapply(nrow(evis_df_s4_2), function(x){
#   pixelly[i] <- evis_df_s4_2 %>%
#   arrange() %>% slice(i) %>% 
#   t()
# })

all_pixels <- evis_df_s4_2 %>% 
  select (-c(x, y)) %>%
  arrange() %>% 
  slice(1:nrow(evis_df_s4_2)) %>% 
  t() 

str(all_pixels)


# #create time series 
# 

EVIseries <- ts(all_pixels, start=c(2000, 1), end=c(2007, 12), frequency=12)




# matrix1 <- matrix() 
# mapply(all_pixels, function(x){
#   ts(x, start=c(2000, 1), end=c(2004, 1), frequency=12)
#   
# })

#Create copy of time series matrix to mess with
yt <- EVIseries


#remember, row,column
yt[,1]
#Will encounter the following error if we attempt to plot more than 10 pixels of data -----
#Error in plotts(x = x, y = y, plot.type = plot.type, xy.labels = xy.labels,  : cannot plot more than 10 series as "multiple"
plot(yt[,1:10])


# time series pre-processing ---interpolating 

#Will encounter error if we attempt to plot more than 1 row
#the condition has length > 1 and only the first element will be usedError in TsPP(EVIseries2[, 1:2], tsgf = TSGFspline) : TsPP: Yt should be class of 'ts'.


xc <- EVIseries[,1]
Yt_interpolate_m_test <- TsPP(EVIseries[,1], tsgf=TSGFspline)
plot(Yt_interpolate_m_test)

# mapply(all_pixels, function(x){
#   ts(x, start=c(2000, 1), end=c(2004, 1), frequency=12)
#   
# })


tii <- seq(1,ncol(EVIseries))


#Create empty lists for lapply
Yt_interpolate_m <- list()
Yt_interpolate_m2 <- list()


#Apply Tspp # time series pre-processing ---interpolating across whole data set.  Use lapply to retain time series information. 
ww <- ncol(EVIseries)
Yt_interpolate_m2 <- lapply(seq(ww), function(x){
Yt_interpolate_m[[x]]  <- TsPP(EVIseries[,x], tsgf=TSGFspline)
})

# for(i in seq(ww)){
# Yt_interpolate_m[[i]] <- TsPP(EVIseries[,i], tsgf=TSGFspline)
# }


#calculate metrics
# Phen_2000_2007 <- Phenology(Yt_interpolate_m2, approach="White")



#Extract years from dates 
y <- data.frame(Date=(seq(dates[1], dates[length(dates)], by = 'year')))
y$Year<-year(y$Date)
years <- y$Year



#Create empty loop for list
Phen_2000_2007_2 <- list()

for(i in seq(ww)){
Phen_2000_2007_2[[i]] <- Phenology(Yt_interpolate_m2[[i]], approach="White")
}


# sost <- data.frame(seq(ww))
# namevector <- c("sos", "eos", 'los', 'pop')
# sost[ , namevector] <- NA
# 
# sostibbless <- tibble(ID,SOS,EOS,LOS,POP)
# 
# 
# sostibbles <- tibble("Id","sos", "eos", 'los', 'pop')
# namevector <- c("sos", "eos", 'los', 'pop')
# sostibble[ , namevector] <- NA


# seq_len(ww)
# seq_along()



#Create empty list containers for loop
sos <- list()
eos <- list()
los <- list()
pop <- list()


for(i in seq(ncol(EVIseries))){
sos[[i]] <-  as.numeric( Phen_2000_2007_2[[i]][["sos"]])
eos[[i]] <-  as.numeric( Phen_2000_2007_2[[i]][["eos"]])
los[[i]] <-  as.numeric( Phen_2000_2007_2[[i]][["los"]])
pop[[i]] <-  as.numeric( Phen_2000_2007_2[[i]][["pop"]])

}

sos <- unlist(sos)
eos <- unlist(eos)
los <- unlist(los)
pop <- unlist(pop)


coords <-evis_df_s4_2 %>% select(x, y) 
coords2 <- coords %>% slice(rep(1:n(), each = 8))


DF_phenmet_test <- data.frame(coords2,sos, eos, los, pop) %>% cbind(years)

DF_phenmet_testarranged <- DF_phenmet_test %>% arrange(years)


DF_phenmet_testarranged_sf = st_as_sf(DF_phenmet_testarranged, coords = c("x", "y"), crs = 4326)
par(mar = c(0, 0, 0, 0))
ggplot() +
  geom_sf(data = eco_mask2, fill = "grey")+
  geom_sf(data= DF_phenmet_testarranged_sf)


DF_phenmet_raster<- rasterFromXYZ(DF_phenmet_testarranged, crs = '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs')

plot(DF_phenmet_raster)

# 
# xy.list <- split(coords, seq(nrow(coords)))
# 
# xy.list2 <- as.list(as.data.frame(t(coords)))
# 
# coords2 <- coords %>% slice(rep(1:n(), each = 8))
# 



# (tii[i],Phen_2000_2007_2[[i]][["sos"]], years) %>% group_by(years)


# sos <- rbind(sos, new.baskets)
# 
# 
# 
# str(sos)
# eos <-  as.numeric( Phen_2000_2007_2[["eos"]])
# str(eos)
# los <-  as.numeric( Phen_2000_2007_2[["los"]])
# str(los)
# pop <-  as.numeric( Phen_2000_2007_2[["pop"]])
# str(pop)
# 
# data.frame(coords, sos, eos, los, pop) %>% cbind(years) 
# 




# 
# plot(Phen_2000_2007)
# #just 2000
# x <- TsPP(EVIseries[,1], interpolate=TRUE)[1:365]
# plot(x)
# # calculate phenology metrics for first year (2000)and plot graph
#  PhenoDeriv(x, plot=TRUE, xlab = "Day Of Year", ylab = "EVI")
# #Plots SOS, EOS, POP, LOS
# plot(Phen_2000_2007[["sos"]])
# plot(Phen_2000_2007[["eos"]])
# plot(Phen_2000_2007[["pop"]])
# plot(Phen_2000_2007[["los"]])


#Calculate metrics for whole matrix

# ww2 <- ncol(Yt_interpolate_m2)
# 
# Phen_2000_2007_matrix <- sapply(seq(ww2), function(x){
# Yt_interpolate_m[[x]]  <- TsPP(EVIseries[,x], tsgf=TSGFspline)
# Phenology(Yt_interpolate_m2, approach="White")
# })
# 

# 
# Phen_2000_2007 <- Phenology(Yt_interpolate, approach="White")
# plot(Phen_2000_2007)
# #just 2000
# 
# sos <- as.numeric( Phen_2000_2007[["sos"]])
# str(sos)
# eos <-  as.numeric( Phen_2000_2007[["eos"]])
# str(eos)
# los <-  as.numeric( Phen_2000_2007[["los"]])
# str(los)
# pop <-  as.numeric( Phen_2000_2007[["pop"]])
# str(pop)
# 
# 
# 
# 


# extract variables of choice 
sos <- as.numeric( Phen_2000_2007[["sos"]])
str(sos)
eos <-  as.numeric( Phen_2000_2007[["eos"]])
str(eos)
los <-  as.numeric( Phen_2000_2007[["los"]])
str(los)
pop <-  as.numeric( Phen_2000_2007[["pop"]])
str(pop)



# #coordinates for first pixel
# coords <-evis_df_s4_2 %>% select(x, y) %>% slice(1)
# # y<-data.frame(Date=(seq(as.Date('2000/01/01'),as.Date('2008/01/01'), by="year")))   #create the year column
# 
# # y$Year<-year(y$Date)
# # years <- y$Year
# 
# y <- data.frame(Date=(seq(dates[1], dates[length(dates)], by = 'year')))
# y$Year<-year(y$Date)
# years <- y$Year
# 
# #Dataframe
# DF_phenmet <- data.frame(coords, sos, eos, los, pop) %>% cbind(years) 
# #convert into SF object 
# DF_phenmet_sf = st_as_sf(DF_phenmet, coords = c("x", "y"), crs = 4326)
# par(mar = c(0, 0, 0, 0))
# ggplot() +
#   geom_sf(data = eco_mask2, fill = "grey")+
#   geom_sf(data= DF_phenmet_sf, col = "blue")
#force into raster
# rast <- raster()
# extent(rast) <- extent(DF_phenmet_sf) # this might be unnecessary
# ncol(rast) <- 20 # this is one way of assigning cell size / resolution
# nrow(rast) <- 20
# rast2 <- rasterize(DF_phenmet_sf$sos, rast,  fun=mean) 
```

Loop over 4 pixels, convert into sf object, then into raster 
```{r}
```




Loop over 4 pixels, convert into sf object, then into raster 
```{r}
```




```{r}
#-------------------------------------------------------------------
#Extrating phenology using Green Brown Package
#Demo code
# load a multi-temporal raster dataset of Normalized Difference Vegetation Index
library(greenbrown)
data(ndvimap)
data(ndvi)
plot(ndvimap, 13)
plot(XYZ_S4, 13)


# calculate phenology metrics (this can take some time!)
# Parallel computing??
#took a couple hours-- How can we reduce time!!



library(greenbrown)
#load example NDVI time series. 
data0 = read.csv("~/Downloads/ee-chart.csv", header=T, sep=",")
NDVI0 = data0$NDVI
NDVIseries = ts(NDVI0, start=c(2018,1), frequency = 23)
plot(NDVIseries)
ndvi=NDVI
seriesprint(ndvi)

## time series pre-processing.
x <- TsPP(ndvi, interpolate = TRUE)[366:700]
plot(x)
#calculate phenology metrics for first year.
PhenoDeriv(x, plot=TRUE)


TSGFssa
# phenmap <- PhenologyRaster(XYZ_S4, start=c(2000, 1), freq=12, tsgf="TSGFlinear", approach="Deriv")
# phenmap <- PhenologyRaster(XYZ_S4, start=c(2000, 1), freq=12, tsgf="TSGFssa", approach="Deriv")
# phenmap <- PhenologyRaster(XYZ_S4, start=c(2000, 1), freq=12, tsgf = "TSGFdoublelog", approach="Trs", min.mean	= .0)
#phenmap <- PhenologyRaster(XYZ_S4, start=c(2000, 1), freq=12, tsgf = "TSGFspline", approach="Trs", fpg = NULL)
#phenmap <- PhenologyRaster(XYZ_S4, start=c(2000, 1), freq=12, tsgf = "TSGFspline", approach="Trs", fpg = NULL, interpolate = TRUE)

XYZ_S4
phenmap <- PhenologyRaster(XYZ_S4, start=c(2000, 1), freq=12, tsgf = "TSGFlinear", approach="Trs")
phenmap <- PhenologyRaster(xyzstack, start=c(2000, 1), freq=12, tsgf = "TSGFlinear", approach="Trs")


phenmap <- PhenologyRaster(xyzstack, start=c(2000, 1), freq=12, tsgf="TSGFlinear", check.seasonality=NULL, approach="Trs")
#tsgf=NULL, approach="Deriv", check.seasonality=NULL

phenmap <- PhenologyRaster(XYZ_S4, start=c(2000, 1), min.mean	= .01, freq=12, fpg = NULL, approach="Deriv", interpolate = TRUE)

IsPermanentGap(XYZ_S4)

# Select method by defining 'tsgf' (temporal smoothing and gap filling) and
# by 'approach' (method to summarize phenology metrics).
# See \code{\link{Phenology}} for examples and a comparison of methods.
#----------------------------------------------------------------------------------

plot(phenmap)
par(mar = c(2, 2, 2, 2))
par(mar = c(1, 1, 1, 1))
plot(phenmap, grep("SOS.2000", names(phenmap))) # start of season 2000
plot(phenmap, grep("EOS.2000", names(phenmap))) # end of season 2000
plot(phenmap, grep("LOS.2000", names(phenmap))) # length of season 2000
plot(phenmap, grep("POP.2000", names(phenmap))) # position of peak value 2000
plot(phenmap, grep("POT.2000", names(phenmap))) # position of trough value 2000
plot(phenmap, grep("MGS.2000", names(phenmap))) # mean growing season value 2000
plot(phenmap, grep("PEAK.2000", names(phenmap))) # peak value 2000
plot(phenmap, grep("TROUGH.2000", names(phenmap))) # trough value 2000
plot(phenmap, grep("MSP.2000", names(phenmap))) # mean spring value 2000
plot(phenmap, grep("MAU.2000", names(phenmap))) # mean autumn value 2000
plot(phenmap, grep("RSP.2000", names(phenmap))) # rate of spring greenup 2000
plot(phenmap, grep("RAU.2000", names(phenmap))) # rate of autumn senescence 2000

# calculate trends on length of season using TrendRaster
losmap <- subset(phenmap, grep("LOS", names(phenmap)))
plot(losmap)
lostrend <- TrendRaster(losmap, start=c(2000, 1), freq=1)
plot(lostrend)

# classify trends in length of season
lostrend.cl <- TrendClassification(lostrend)
plot(lostrend.cl, col=brgr.colors(3), breaks=c(-1.5, -0.5, 0.5, 1.5))
# only a few pixels have a positive trend in the length of growing season













d2 <- data(ndvi)
phenmap2 <- PhenologyRaster(ndvimap, start=c(2000, 1), freq=12,
                           tsgf="TSGFspline", approach="Deriv")
# Select method by defining 'tsgf' (temporal smoothing and gap filling) and
# by 'approach' (method to summarize phenology metrics).
# See \code{\link{Phenology}} for examples and a comparison of methods.
#----------------------------------------------------------------------------------
```

